(module xsd
  (@doc "XSD datatype parsing and value-space equality for RDF literals")

  (import rdf (Term Literal))
  (import strlib (parse-int parse-float))
  (import vocab (XSD_STRING XSD_INTEGER XSD_BOOLEAN XSD_DECIMAL XSD_FLOAT XSD_DOUBLE
                 XSD_LONG XSD_INT XSD_SHORT XSD_BYTE
                 XSD_NON_NEGATIVE_INTEGER XSD_NON_POSITIVE_INTEGER
                 XSD_POSITIVE_INTEGER XSD_NEGATIVE_INTEGER
                 XSD_UNSIGNED_LONG XSD_UNSIGNED_INT XSD_UNSIGNED_SHORT XSD_UNSIGNED_BYTE
                 RDF_LANG_STRING))

  (export
    XsdType
    XsdValue
    XsdError
    XsdCompareResult
    xsd-parse-type
    xsd-parse-value
    xsd-validate-lexical
    xsd-values-equal
    xsd-types-compatible
    literal-values-equal
    xsd-values-compare
    xsd-compare)

  ;; Supported XSD types (Phase 1: core types only)
  (type XsdType (enum
    xsd-string
    xsd-integer
    xsd-decimal
    xsd-float
    xsd-double
    xsd-boolean
    xsd-unknown))

  ;; Parsed XSD value in value space
  (type XsdValue (union
    (xsd-string-val String)
    (xsd-integer-val Int)
    (xsd-decimal-val Float)
    (xsd-float-val F32)
    (xsd-double-val Float)
    (xsd-boolean-val Bool)
    (xsd-unknown-val String)))

  ;; Parse errors
  (type XsdError (enum
    invalid-lexical-form
    unsupported-datatype
    type-mismatch))

  ;; Comparison result for XSD value ordering
  (type XsdCompareResult (enum
    xsd-compare-less
    xsd-compare-equal
    xsd-compare-greater
    xsd-compare-incomparable))

  (fn xsd-parse-type ((in datatype-iri String))
    (@intent "Parse XSD datatype IRI to enum, returning xsd-unknown for unrecognized types")
    (@spec ((String) -> XsdType))
    (@pure)
    (@example ("http://www.w3.org/2001/XMLSchema#string") -> 'xsd-string)
    (@example ("http://www.w3.org/2001/XMLSchema#integer") -> 'xsd-integer)
    (@example ("http://www.w3.org/2001/XMLSchema#boolean") -> 'xsd-boolean)
    (@example ("http://example.org/custom") -> 'xsd-unknown)
    (cond
      ((string-eq datatype-iri XSD_STRING) 'xsd-string)
      ((string-eq datatype-iri XSD_INTEGER) 'xsd-integer)
      ((string-eq datatype-iri XSD_BOOLEAN) 'xsd-boolean)
      ((string-eq datatype-iri XSD_DECIMAL) 'xsd-decimal)
      ((string-eq datatype-iri XSD_FLOAT) 'xsd-float)
      ((string-eq datatype-iri XSD_DOUBLE) 'xsd-double)
      (else 'xsd-unknown))
    :c-name "xsd_parse_type")

  (fn xsd-parse-value ((in arena Arena) (in lexical String) (in dtype XsdType))
    (@intent "Parse lexical form to typed value according to XSD datatype")
    (@spec ((Arena String XsdType) -> (Result XsdValue XsdError)))
    (@alloc arena)
    (@example ("hello" 'xsd-string) -> (ok (union-new XsdValue xsd-string-val "hello")))
    (@example ("42" 'xsd-integer) -> (ok (union-new XsdValue xsd-integer-val 42)))
    (@example ("true" 'xsd-boolean) -> (ok (union-new XsdValue xsd-boolean-val true)))
    (@example ("false" 'xsd-boolean) -> (ok (union-new XsdValue xsd-boolean-val false)))
    (@example ("3.14" 'xsd-decimal) -> (ok (union-new XsdValue xsd-decimal-val 3.14)))
    (@example ("not-a-number" 'xsd-integer) -> (error 'invalid-lexical-form))
    (match dtype
      (xsd-string
        (ok (union-new XsdValue xsd-string-val lexical)))
      (xsd-integer
        (match (parse-int lexical)
          ((ok val) (ok (union-new XsdValue xsd-integer-val val)))
          ((error _) (error 'invalid-lexical-form))))
      (xsd-boolean
        (if (string-eq lexical "true")
          (ok (union-new XsdValue xsd-boolean-val true))
          (if (string-eq lexical "false")
            (ok (union-new XsdValue xsd-boolean-val false))
            (error 'invalid-lexical-form))))
      (xsd-decimal
        (match (parse-float lexical)
          ((ok val) (ok (union-new XsdValue xsd-decimal-val val)))
          ((error _) (error 'invalid-lexical-form))))
      (xsd-float
        (match (parse-float lexical)
          ((ok val) (ok (union-new XsdValue xsd-float-val (cast F32 val))))
          ((error _) (error 'invalid-lexical-form))))
      (xsd-double
        (match (parse-float lexical)
          ((ok val) (ok (union-new XsdValue xsd-double-val val)))
          ((error _) (error 'invalid-lexical-form))))
      (xsd-unknown
        (ok (union-new XsdValue xsd-unknown-val lexical))))
    :c-name "xsd_parse_value")

  (fn xsd-validate-lexical ((in lexical String) (in datatype-iri String))
    (@intent "Validate a lexical form against an XSD datatype IRI")
    (@spec ((String String) -> Bool))
    (@pure)
    ;; Tier 1: core XSD types — delegate to xsd-parse-value
    (cond
      ((string-eq datatype-iri XSD_STRING) true)
      ((string-eq datatype-iri XSD_INTEGER)
        (match (parse-int lexical)
          ((ok _) true)
          ((error _) false)))
      ((string-eq datatype-iri XSD_BOOLEAN)
        (or (string-eq lexical "true")
            (string-eq lexical "false")
            (string-eq lexical "1")
            (string-eq lexical "0")))
      ((string-eq datatype-iri XSD_DECIMAL)
        (match (parse-float lexical)
          ((ok _) true)
          ((error _) false)))
      ((string-eq datatype-iri XSD_FLOAT)
        (match (parse-float lexical)
          ((ok _) true)
          ((error _) false)))
      ((string-eq datatype-iri XSD_DOUBLE)
        (match (parse-float lexical)
          ((ok _) true)
          ((error _) false)))
      ;; Tier 2: integer subtypes — parse-int + range check
      ((string-eq datatype-iri XSD_LONG)
        (match (parse-int lexical)
          ((ok _) true)
          ((error _) false)))
      ((string-eq datatype-iri XSD_INT)
        (match (parse-int lexical)
          ((ok v) (and (>= v -2147483648) (<= v 2147483647)))
          ((error _) false)))
      ((string-eq datatype-iri XSD_SHORT)
        (match (parse-int lexical)
          ((ok v) (and (>= v -32768) (<= v 32767)))
          ((error _) false)))
      ((string-eq datatype-iri XSD_BYTE)
        (match (parse-int lexical)
          ((ok v) (and (>= v -128) (<= v 127)))
          ((error _) false)))
      ((string-eq datatype-iri XSD_UNSIGNED_LONG)
        (match (parse-int lexical)
          ((ok v) (>= v 0))
          ((error _) false)))
      ((string-eq datatype-iri XSD_UNSIGNED_INT)
        (match (parse-int lexical)
          ((ok v) (and (>= v 0) (<= v 4294967295)))
          ((error _) false)))
      ((string-eq datatype-iri XSD_UNSIGNED_SHORT)
        (match (parse-int lexical)
          ((ok v) (and (>= v 0) (<= v 65535)))
          ((error _) false)))
      ((string-eq datatype-iri XSD_UNSIGNED_BYTE)
        (match (parse-int lexical)
          ((ok v) (and (>= v 0) (<= v 255)))
          ((error _) false)))
      ((string-eq datatype-iri XSD_NON_NEGATIVE_INTEGER)
        (match (parse-int lexical)
          ((ok v) (>= v 0))
          ((error _) false)))
      ((string-eq datatype-iri XSD_POSITIVE_INTEGER)
        (match (parse-int lexical)
          ((ok v) (>= v 1))
          ((error _) false)))
      ((string-eq datatype-iri XSD_NEGATIVE_INTEGER)
        (match (parse-int lexical)
          ((ok v) (<= v -1))
          ((error _) false)))
      ((string-eq datatype-iri XSD_NON_POSITIVE_INTEGER)
        (match (parse-int lexical)
          ((ok v) (<= v 0))
          ((error _) false)))
      ;; Skip langString — validated by lang tag presence, not lexical form
      ((string-eq datatype-iri RDF_LANG_STRING) true)
      ;; Tier 3/4 and unknown types: return true (spec-compliant)
      (else true))
    :c-name "xsd_validate_lexical")

  (fn xsd-values-equal ((in a XsdValue) (in b XsdValue))
    (@intent "Compare two XSD values for equality in value space")
    (@spec ((XsdValue XsdValue) -> Bool))
    (@pure)
    (@example ((xsd-integer-val 42) (xsd-integer-val 42)) -> true)
    (@example ((xsd-integer-val 42) (xsd-decimal-val 42.0)) -> true)
    (@example ((xsd-string-val "foo") (xsd-string-val "foo")) -> true)
    (@example ((xsd-string-val "foo") (xsd-string-val "bar")) -> false)
    (@example ((xsd-boolean-val true) (xsd-boolean-val true)) -> true)
    (match a
      ((xsd-string-val s1)
       (match b
         ((xsd-string-val s2) (string-eq s1 s2))
         (_ false)))
      ((xsd-integer-val i1)
       (match b
         ((xsd-integer-val i2) (== i1 i2))
         ((xsd-decimal-val d2) (== (cast Float i1) d2))
         ((xsd-float-val f2) (== (cast Float i1) (cast Float f2)))
         ((xsd-double-val d2) (== (cast Float i1) d2))
         (_ false)))
      ((xsd-decimal-val d1)
       (match b
         ((xsd-integer-val i2) (== d1 (cast Float i2)))
         ((xsd-decimal-val d2) (== d1 d2))
         ((xsd-float-val f2) (== d1 (cast Float f2)))
         ((xsd-double-val d2) (== d1 d2))
         (_ false)))
      ((xsd-float-val f1)
       (match b
         ((xsd-integer-val i2) (== (cast Float f1) (cast Float i2)))
         ((xsd-decimal-val d2) (== (cast Float f1) d2))
         ((xsd-float-val f2) (== f1 f2))
         ((xsd-double-val d2) (== (cast Float f1) d2))
         (_ false)))
      ((xsd-double-val d1)
       (match b
         ((xsd-integer-val i2) (== d1 (cast Float i2)))
         ((xsd-decimal-val d2) (== d1 d2))
         ((xsd-float-val f2) (== d1 (cast Float f2)))
         ((xsd-double-val d2) (== d1 d2))
         (_ false)))
      ((xsd-boolean-val b1)
       (match b
         ((xsd-boolean-val b2) (== b1 b2))
         (_ false)))
      ((xsd-unknown-val u1)
       (match b
         ((xsd-unknown-val u2) (string-eq u1 u2))
         (_ false))))
    :c-name "xsd_values_equal")

  (fn xsd-types-compatible ((in t1 XsdType) (in t2 XsdType))
    (@intent "Check if two XSD types are comparable (same type or both numeric)")
    (@spec ((XsdType XsdType) -> Bool))
    (@pure)
    (@example ('xsd-integer 'xsd-integer) -> true)
    (@example ('xsd-integer 'xsd-decimal) -> true)
    (@example ('xsd-string 'xsd-integer) -> false)
    (@example ('xsd-float 'xsd-double) -> true)
    (or (== t1 t2)
        (and (or (== t1 'xsd-integer) (== t1 'xsd-decimal) (== t1 'xsd-float) (== t1 'xsd-double))
             (or (== t2 'xsd-integer) (== t2 'xsd-decimal) (== t2 'xsd-float) (== t2 'xsd-double))))
    :c-name "xsd_types_compatible")

  (fn literal-values-equal ((in arena Arena) (in a Literal) (in b Literal))
    (@intent "Compare two RDF literals for value-space equality considering datatypes")
    (@spec ((Arena Literal Literal) -> (Result Bool XsdError)))
    (@alloc arena)
    (match (. a lang)
      ((some lang-a)
       (match (. b lang)
         ((some lang-b)
          (if (string-eq lang-a lang-b)
            (ok (string-eq (. a value) (. b value)))
            (ok false)))
         ((none) (ok false))))
      ((none)
       (match (. a datatype)
         ((some dt-a)
          (match (. b datatype)
            ((some dt-b)
             (let ((type-a (xsd-parse-type dt-a)))
               (let ((type-b (xsd-parse-type dt-b)))
                 (let ((val-a (? (xsd-parse-value arena (. a value) type-a))))
                   (let ((val-b (? (xsd-parse-value arena (. b value) type-b))))
                     (ok (xsd-values-equal val-a val-b)))))))
            ((none) (ok false))))
         ((none)
          (match (. b datatype)
            ((some dt-b) (ok false))
            ((none) (ok (string-eq (. a value) (. b value)))))))))
    :c-name "xsd_literal_values_equal")

  ;; ============================================================
  ;; XSD Value Comparison (ordering)
  ;; ============================================================

  (fn float-cmp ((in a Float) (in b Float))
    (@intent "Compare two floats, returning ordering")
    (@spec ((Float Float) -> XsdCompareResult))
    (@pure)
    (if (< a b) 'xsd-compare-less
      (if (> a b) 'xsd-compare-greater
        'xsd-compare-equal))
    :c-name "xsd_float_cmp")

  (fn xsd-values-compare ((in a XsdValue) (in b XsdValue))
    (@intent "Compare two XSD values, returning ordering")
    (@spec ((XsdValue XsdValue) -> XsdCompareResult))
    (@pure)
    (match a
      ((xsd-integer-val i1)
        (let ((d1 (cast Float i1)))
          (match b
            ((xsd-integer-val i2) (float-cmp d1 (cast Float i2)))
            ((xsd-decimal-val d2) (float-cmp d1 d2))
            ((xsd-float-val f2) (float-cmp d1 (cast Float f2)))
            ((xsd-double-val d2) (float-cmp d1 d2))
            (_ 'xsd-compare-incomparable))))
      ((xsd-decimal-val d1)
        (match b
          ((xsd-integer-val i2) (float-cmp d1 (cast Float i2)))
          ((xsd-decimal-val d2) (float-cmp d1 d2))
          ((xsd-float-val f2) (float-cmp d1 (cast Float f2)))
          ((xsd-double-val d2) (float-cmp d1 d2))
          (_ 'xsd-compare-incomparable)))
      ((xsd-float-val f1)
        (let ((d1 (cast Float f1)))
          (match b
            ((xsd-integer-val i2) (float-cmp d1 (cast Float i2)))
            ((xsd-decimal-val d2) (float-cmp d1 d2))
            ((xsd-float-val f2) (float-cmp d1 (cast Float f2)))
            ((xsd-double-val d2) (float-cmp d1 d2))
            (_ 'xsd-compare-incomparable))))
      ((xsd-double-val d1)
        (match b
          ((xsd-integer-val i2) (float-cmp d1 (cast Float i2)))
          ((xsd-decimal-val d2) (float-cmp d1 d2))
          ((xsd-float-val f2) (float-cmp d1 (cast Float f2)))
          ((xsd-double-val d2) (float-cmp d1 d2))
          (_ 'xsd-compare-incomparable)))
      ((xsd-string-val s1)
        (match b
          ((xsd-string-val s2)
            (if (string-eq s1 s2) 'xsd-compare-equal 'xsd-compare-incomparable))
          (_ 'xsd-compare-incomparable)))
      ((xsd-boolean-val b1)
        (match b
          ((xsd-boolean-val b2)
            (if (== b1 b2) 'xsd-compare-equal
              (if b2 'xsd-compare-less 'xsd-compare-greater)))
          (_ 'xsd-compare-incomparable)))
      ((xsd-unknown-val _)
        'xsd-compare-incomparable))
    :c-name "xsd_values_compare")

  (fn xsd-compare ((arena Arena) (a Term) (b Term))
    (@intent "Compare two RDF terms using XSD value-space ordering")
    (@spec ((Arena Term Term) -> XsdCompareResult))
    (@alloc arena)
    (match a
      ((term-literal lit-a)
        (match b
          ((term-literal lit-b)
            (let ((dt-a (match (. lit-a datatype)
                          ((some d) d)
                          ((none) XSD_STRING)))
                  (dt-b (match (. lit-b datatype)
                          ((some d) d)
                          ((none) XSD_STRING))))
              (let ((type-a (xsd-parse-type dt-a))
                    (type-b (xsd-parse-type dt-b)))
                (if (not (xsd-types-compatible type-a type-b))
                  'xsd-compare-incomparable
                  (match (xsd-parse-value arena (. lit-a value) type-a)
                    ((ok val-a)
                      (match (xsd-parse-value arena (. lit-b value) type-b)
                        ((ok val-b) (xsd-values-compare val-a val-b))
                        ((error _) 'xsd-compare-incomparable)))
                    ((error _) 'xsd-compare-incomparable))))))
          (_ 'xsd-compare-incomparable)))
      (_ 'xsd-compare-incomparable))
    :c-name "xsd_compare"))
