(module index
  (@doc "Indexed RDF graph with SPO/PSO/OSP indexes for efficient pattern matching")

  (import rdf (Term Triple Graph term-eq triple-subject triple-predicate triple-object make-triple))

  (export
    TripleSet
    TripleMap
    TripleIndex
    IndexedGraph
    indexed-graph-create
    indexed-graph-add
    indexed-graph-contains
    indexed-graph-match
    indexed-graph-for-each
    indexed-graph-size
    indexed-graph-subjects
    indexed-graph-objects)

  ;; Set of triples (leaf level of index)
  (type TripleSet (Set Triple))

  ;; Map from Term to TripleSet (second-level index)
  (type TripleMap (Map Term TripleSet))

  ;; Triple index with three access patterns - stores full Triple at leaf
  (type TripleIndex (record
    (spo (Map Term TripleMap))   ;; subject -> predicate -> Set[Triple]
    (pso (Map Term TripleMap))   ;; predicate -> subject -> Set[Triple]
    (osp (Map Term TripleMap)))) ;; object -> subject -> Set[Triple]

  ;; Graph with indexes for O(1) lookups
  (type IndexedGraph (record
    (triples (List Triple))
    (index TripleIndex)
    (size (Int 0 ..))))

  (fn indexed-graph-create ((in arena Arena))
    (@intent "Create an empty indexed graph")
    (@spec ((Arena) -> IndexedGraph))
    (@alloc arena)
    (@post (== (. $result size) 0))
    (record-new IndexedGraph
      (triples (list-new arena Triple))
      (index (record-new TripleIndex
               (spo (map-new arena Term TripleMap))
               (pso (map-new arena Term TripleMap))
               (osp (map-new arena Term TripleMap))))
      (size 0))
    :c-name "rdf_indexed_graph_create")

  (fn indexed-graph-add ((in arena Arena) (mut g IndexedGraph) (in t Triple))
    (@intent "Add a triple to the indexed graph, updating all three indexes")
    (@spec ((Arena IndexedGraph Triple) -> IndexedGraph))
    (@alloc arena)
    (@pre (>= (. g size) 0))
    (@post (>= (. $result size) (. g size)))
    ;; Skip if already present (dedup)
    (when (indexed-graph-contains g t)
      (return g))
    (let ((s (triple-subject t))
          (p (triple-predicate t))
          (o (triple-object t)))
      ;; Add to triples list
      (list-push (. g triples) t)
      ;; Update SPO index: subject -> predicate -> Set[Triple]
      (let ((spo-idx (. (. g index) spo)))
        (match (map-get spo-idx s)
          ((some pred-map)
            (match (map-get pred-map p)
              ((some triple-set) (set-put triple-set t))
              ((none)
                (let ((ts (set-new arena Triple)))
                  (set-put ts t)
                  (map-put pred-map p ts)))))
          ((none)
            (let ((pred-map (map-new arena Term TripleSet))
                  (ts (set-new arena Triple)))
              (set-put ts t)
              (map-put pred-map p ts)
              (map-put spo-idx s pred-map)))))
      ;; Update PSO index: predicate -> subject -> Set[Triple]
      (let ((pso-idx (. (. g index) pso)))
        (match (map-get pso-idx p)
          ((some subj-map)
            (match (map-get subj-map s)
              ((some triple-set) (set-put triple-set t))
              ((none)
                (let ((ts (set-new arena Triple)))
                  (set-put ts t)
                  (map-put subj-map s ts)))))
          ((none)
            (let ((subj-map (map-new arena Term TripleSet))
                  (ts (set-new arena Triple)))
              (set-put ts t)
              (map-put subj-map s ts)
              (map-put pso-idx p subj-map)))))
      ;; Update OSP index: object -> subject -> Set[Triple]
      (let ((osp-idx (. (. g index) osp)))
        (match (map-get osp-idx o)
          ((some subj-map)
            (match (map-get subj-map s)
              ((some triple-set) (set-put triple-set t))
              ((none)
                (let ((ts (set-new arena Triple)))
                  (set-put ts t)
                  (map-put subj-map s ts)))))
          ((none)
            (let ((subj-map (map-new arena Term TripleSet))
                  (ts (set-new arena Triple)))
              (set-put ts t)
              (map-put subj-map s ts)
              (map-put osp-idx o subj-map)))))
      ;; Return updated graph
      (record-new IndexedGraph
        (triples (. g triples))
        (index (. g index))
        (size (+ (. g size) 1))))
    :c-name "rdf_indexed_graph_add")

  (fn indexed-graph-contains ((in g IndexedGraph) (in t Triple))
    (@intent "Check if graph contains a specific triple using SPO index")
    (@spec ((IndexedGraph Triple) -> Bool))
    (@pure)
    (@pre (>= (. g size) 0))
    ;; Semantic axioms: contains iff triple exists in g.triples
    (@assume (implies (exists (t2 (. g triples)) (triple-eq t t2)) $result))
    (@assume (implies $result (exists (t2 (. g triples)) (triple-eq t t2))))
    (let ((s (triple-subject t))
          (p (triple-predicate t))
          (spo-idx (. (. g index) spo)))
      (match (map-get spo-idx s)
        ((some pred-map)
          (match (map-get pred-map p)
            ((some triple-set) (set-has triple-set t))
            ((none) false)))
        ((none) false)))
    :c-name "rdf_indexed_graph_contains")

  (fn indexed-graph-match ((in arena Arena) (in g IndexedGraph) (in subj (Option Term)) (in pred (Option Term)) (in obj (Option Term)))
    (@intent "Find all triples matching pattern - returns existing triples without allocation")
    (@spec ((Arena IndexedGraph (Option Term) (Option Term) (Option Term)) -> (List Triple)))
    (@alloc arena)
    (@pre (>= (. g size) 0))
    (@post (>= (list-len $result) 0))
    ;; Results are subset of all triples in graph
    (@assume (forall (t $result)
               (exists (t2 (. g triples))
                 (triple-eq t t2))))
    ;; Results are contained in graph (bridges match â†’ contains)
    (@assume (forall (t $result) (indexed-graph-contains g t)))
    ;; Filtering: when a pattern parameter is (some x), all results match on that field
    (@assume (implies (!= subj (none))
               (forall (t $result) (term-eq (triple-subject t) (unwrap subj)))))
    (@assume (implies (!= pred (none))
               (forall (t $result) (term-eq (triple-predicate t) (unwrap pred)))))
    (@assume (implies (!= obj (none))
               (forall (t $result) (term-eq (triple-object t) (unwrap obj)))))
    ;; Membership postcondition for all-none case: all g.triples are in result
    (@assume (implies (and (== subj (none)) (== pred (none)) (== obj (none)))
               (forall (t (. g triples))
                 (exists (t2 $result) (triple-eq t t2)))))
    ;; Use index-based dispatch for O(1) lookup instead of full scan
    (let ((mut result (list-new arena Triple)))
      (match subj
        ((some s)
          ;; Subject bound - use SPO index
          (match (map-get (. (. g index) spo) s)
            ((some pred-map)
              (match pred
                ((some p)
                  ;; S+P bound
                  (match (map-get pred-map p)
                    ((some triple-set)
                      (match obj
                        ((some o)
                          ;; S+P+O bound
                          (for-each (t triple-set)
                            (when (term-eq (triple-object t) o)
                              (list-push result t))))
                        ((none)
                          ;; S+P bound, O wildcard
                          (for-each (t triple-set)
                            (list-push result t)))))
                    ((none) (do))))
                ((none)
                  ;; Only S bound
                  (for-each ((p triple-set) pred-map)
                    (match obj
                      ((some o)
                        (for-each (t triple-set)
                          (when (term-eq (triple-object t) o)
                            (list-push result t))))
                      ((none)
                        (for-each (t triple-set)
                          (list-push result t))))))))
            ((none) (do))))
        ((none)
          ;; Subject not bound
          (match pred
            ((some p)
              ;; Predicate bound - use PSO index
              (match (map-get (. (. g index) pso) p)
                ((some subj-map)
                  (for-each ((s triple-set) subj-map)
                    (match obj
                      ((some o)
                        (for-each (t triple-set)
                          (when (term-eq (triple-object t) o)
                            (list-push result t))))
                      ((none)
                        (for-each (t triple-set)
                          (list-push result t))))))
                ((none) (do))))
            ((none)
              ;; Neither S nor P bound
              (match obj
                ((some o)
                  ;; Only O bound - use OSP index
                  (match (map-get (. (. g index) osp) o)
                    ((some subj-map)
                      (for-each ((s triple-set) subj-map)
                        (for-each (t triple-set)
                          (list-push result t))))
                    ((none) (do))))
                ((none)
                  ;; Nothing bound - iterate all triples
                  (for-each (t (. g triples))
                    (list-push result t))))))))
      result)
    :c-name "rdf_indexed_graph_match")

  (fn indexed-graph-for-each ((in g IndexedGraph)
                              (in subj (Option Term))
                              (in pred (Option Term))
                              (in obj (Option Term))
                              (callback (Fn (Triple) Unit)))
    (@intent "Call callback for each matching triple using indices - zero allocation")
    (@spec ((IndexedGraph (Option Term) (Option Term) (Option Term) (Fn (Triple) Unit)) -> Unit))
    (@pure)
    (@pre (>= (. g size) 0))
    (match subj
      ((some s)
        ;; Subject bound - use SPO index
        (match (map-get (. (. g index) spo) s)
          ((some pred-map)
            (match pred
              ((some p)
                ;; S+P bound
                (match (map-get pred-map p)
                  ((some triple-set)
                    (match obj
                      ((some o)
                        ;; S+P+O bound - filter by object
                        (for-each (t triple-set)
                          (when (term-eq (triple-object t) o)
                            (callback t))))
                      ((none)
                        ;; S+P bound, O wildcard - iterate all
                        (for-each (t triple-set)
                          (callback t)))))
                  ((none) (do))))
              ((none)
                ;; Only S bound - iterate all predicates
                (for-each ((p triple-set) pred-map)
                  (match obj
                    ((some o)
                      (for-each (t triple-set)
                        (when (term-eq (triple-object t) o)
                          (callback t))))
                    ((none)
                      (for-each (t triple-set)
                        (callback t))))))))
          ((none) (do))))
      ((none)
        ;; Subject not bound
        (match pred
          ((some p)
            ;; Predicate bound - use PSO index
            (match (map-get (. (. g index) pso) p)
              ((some subj-map)
                (for-each ((s triple-set) subj-map)
                  (match obj
                    ((some o)
                      (for-each (t triple-set)
                        (when (term-eq (triple-object t) o)
                          (callback t))))
                    ((none)
                      (for-each (t triple-set)
                        (callback t))))))
              ((none) (do))))
          ((none)
            ;; Neither S nor P bound
            (match obj
              ((some o)
                ;; Only O bound - use OSP index
                (match (map-get (. (. g index) osp) o)
                  ((some subj-map)
                    (for-each ((s triple-set) subj-map)
                      (for-each (t triple-set)
                        (callback t))))
                  ((none) (do))))
              ((none)
                ;; Nothing bound - iterate all triples
                (for-each (t (. g triples))
                  (callback t))))))))
    :c-name "rdf_indexed_graph_for_each")

  (fn indexed-graph-size ((in g IndexedGraph))
    (@intent "Return the number of triples in the graph")
    (@spec ((IndexedGraph) -> (Int 0 ..)))
    (@pure)
    (@post (== $result (. g size)))
    (. g size)
    :c-name "rdf_indexed_graph_size")

  (fn indexed-graph-subjects ((in arena Arena) (in g IndexedGraph) (in pred Term) (in obj Term))
    (@intent "Find all subjects with given predicate and object")
    (@spec ((Arena IndexedGraph Term Term) -> (List Term)))
    (@alloc arena)
    (@pre (>= (. g size) 0))
    (let ((mut result (list-new arena Term))
          (osp-idx (. (. g index) osp)))
      (match (map-get osp-idx obj)
        ((some subj-map)
          (for-each ((s triple-set) subj-map)
            ;; Check if any triple in the set has the matching predicate
            (let ((mut found false))
              (for-each (t triple-set)
                (when (and (not found) (term-eq (triple-predicate t) pred))
                  (list-push result s)
                  (set! found true))))))
        ((none) (do)))
      result)
    :c-name "rdf_indexed_graph_subjects")

  (fn indexed-graph-objects ((in arena Arena) (in g IndexedGraph) (in subj Term) (in pred Term))
    (@intent "Find all objects with given subject and predicate")
    (@spec ((Arena IndexedGraph Term Term) -> (List Term)))
    (@alloc arena)
    (@pre (>= (. g size) 0))
    (let ((mut result (list-new arena Term))
          (spo-idx (. (. g index) spo)))
      (match (map-get spo-idx subj)
        ((some pred-map)
          (match (map-get pred-map pred)
            ((some triple-set)
              (for-each (t triple-set)
                (list-push result (triple-object t))))
            ((none) (do))))
        ((none) (do)))
      result)
    :c-name "rdf_indexed_graph_objects"))
