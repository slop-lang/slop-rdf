(module index
  (@doc "Indexed RDF graph with SPO/PSO/OSP indexes for efficient pattern matching")

  (import rdf (Term Triple Graph term-eq triple-subject triple-predicate triple-object make-triple))

  (export
    TermMap
    TripleIndex
    IndexedGraph
    indexed-graph-create
    indexed-graph-add
    indexed-graph-contains
    indexed-graph-match
    indexed-graph-for-each
    indexed-graph-size
    indexed-graph-subjects
    indexed-graph-objects)

  ;; Map from Term to Set of Terms (for second-level index)
  (type TermMap (Map Term (Set Term)))

  ;; Map from Term to TermMap (for first-level index)
  (type TermIndex (Map Term TermMap))

  ;; Triple index with three access patterns
  (type TripleIndex (record
    (spo TermIndex)   ;; subject -> predicate -> objects
    (pso TermIndex)   ;; predicate -> subject -> objects
    (osp TermIndex))) ;; object -> subject -> predicates

  ;; Graph with indexes for O(1) lookups
  (type IndexedGraph (record
    (triples (List Triple))
    (index TripleIndex)
    (size (Int 0 ..))))

  (fn indexed-graph-create ((in arena Arena))
    (@intent "Create an empty indexed graph")
    (@spec ((Arena) -> IndexedGraph))
    (@alloc arena)
    (@post (== (. $result size) 0))
    (record-new IndexedGraph
      (triples (list-new arena Triple))
      (index (record-new TripleIndex
               (spo (map-new arena Term TermMap))
               (pso (map-new arena Term TermMap))
               (osp (map-new arena Term TermMap))))
      (size 0))
    :c-name "rdf_indexed_graph_create")

  (fn indexed-graph-add ((in arena Arena) (mut g IndexedGraph) (in t Triple))
    (@intent "Add a triple to the indexed graph, updating all three indexes")
    (@spec ((Arena IndexedGraph Triple) -> IndexedGraph))
    (@alloc arena)
    (@pre (>= (. g size) 0))
    (@post (>= (. $result size) (. g size)))
    (@post (indexed-graph-contains $result t))
    ;; Skip if already present (dedup)
    (when (indexed-graph-contains g t)
      (return g))
    (let ((s (triple-subject t))
          (p (triple-predicate t))
          (o (triple-object t)))
      ;; Add to triples list
      (list-push (. g triples) t)
      ;; Update SPO index: subject -> predicate -> objects
      (let ((spo-idx (. (. g index) spo)))
        (when (not (map-has spo-idx s))
          (map-put spo-idx s (map-new arena Term (Set Term))))
        (match (map-get spo-idx s)
          ((some pred-map)
            (when (not (map-has pred-map p))
              (map-put pred-map p (set-new arena Term)))
            (match (map-get pred-map p)
              ((some obj-set) (set-put obj-set o))
              ((none) (do))))
          ((none) (do))))
      ;; Update PSO index: predicate -> subject -> objects
      (let ((pso-idx (. (. g index) pso)))
        (when (not (map-has pso-idx p))
          (map-put pso-idx p (map-new arena Term (Set Term))))
        (match (map-get pso-idx p)
          ((some subj-map)
            (when (not (map-has subj-map s))
              (map-put subj-map s (set-new arena Term)))
            (match (map-get subj-map s)
              ((some obj-set) (set-put obj-set o))
              ((none) (do))))
          ((none) (do))))
      ;; Update OSP index: object -> subject -> predicates
      (let ((osp-idx (. (. g index) osp)))
        (when (not (map-has osp-idx o))
          (map-put osp-idx o (map-new arena Term (Set Term))))
        (match (map-get osp-idx o)
          ((some subj-map)
            (when (not (map-has subj-map s))
              (map-put subj-map s (set-new arena Term)))
            (match (map-get subj-map s)
              ((some pred-set) (set-put pred-set p))
              ((none) (do))))
          ((none) (do))))
      ;; Return updated graph
      (record-new IndexedGraph
        (triples (. g triples))
        (index (. g index))
        (size (+ (. g size) 1))))
    :c-name "rdf_indexed_graph_add")

  (fn indexed-graph-contains ((in g IndexedGraph) (in t Triple))
    (@intent "Check if graph contains a specific triple using SPO index")
    (@spec ((IndexedGraph Triple) -> Bool))
    (@pure)
    (@pre (>= (. g size) 0))
    ;; Semantic axioms: contains iff triple exists in g.triples
    (@assume (implies (exists (t2 (. g triples)) (triple-eq t t2)) $result))
    (@assume (implies $result (exists (t2 (. g triples)) (triple-eq t t2))))
    (let ((s (triple-subject t))
          (p (triple-predicate t))
          (o (triple-object t))
          (spo-idx (. (. g index) spo)))
      (match (map-get spo-idx s)
        ((some pred-map)
          (match (map-get pred-map p)
            ((some obj-set) (set-has obj-set o))
            ((none) false)))
        ((none) false)))
    :c-name "rdf_indexed_graph_contains")

  (fn indexed-graph-match ((in arena Arena) (in g IndexedGraph) (in subj (Option Term)) (in pred (Option Term)) (in obj (Option Term)))
    (@intent "Find all triples matching pattern - returns existing triples without allocation")
    (@spec ((Arena IndexedGraph (Option Term) (Option Term) (Option Term)) -> (List Triple)))
    (@alloc arena)
    (@pre (>= (. g size) 0))
    (@post (>= (list-len $result) 0))
    ;; Results are subset of all triples in graph
    (@assume (forall (t $result)
               (exists (t2 (. g triples))
                 (triple-eq t t2))))
    ;; Results are contained in graph (bridges match â†’ contains)
    (@assume (forall (t $result) (indexed-graph-contains g t)))
    ;; Filtering: when a pattern parameter is (some x), all results match on that field
    (@assume (implies (!= subj (none))
               (forall (t $result) (term-eq (triple-subject t) (unwrap subj)))))
    (@assume (implies (!= pred (none))
               (forall (t $result) (term-eq (triple-predicate t) (unwrap pred)))))
    (@assume (implies (!= obj (none))
               (forall (t $result) (term-eq (triple-object t) (unwrap obj)))))
    ;; Membership postcondition for all-none case: all g.triples are in result
    (@assume (implies (and (== subj (none)) (== pred (none)) (== obj (none)))
               (forall (t (. g triples))
                 (exists (t2 $result) (triple-eq t t2)))))
    ;; Simple filtering approach - iterate existing triples, no allocation of new Triple objects
    ;; Trade O(1) index lookup for zero memory allocation per query
    (let ((mut result (list-new arena Triple)))
      (for-each (t (. g triples))
        (let ((matches true))
          (match subj
            ((some s) (when (not (term-eq (triple-subject t) s)) (set! matches false)))
            ((none) (do)))
          (match pred
            ((some p) (when (not (term-eq (triple-predicate t) p)) (set! matches false)))
            ((none) (do)))
          (match obj
            ((some o) (when (not (term-eq (triple-object t) o)) (set! matches false)))
            ((none) (do)))
          (when matches
            (list-push result t))))
      result)
    :c-name "rdf_indexed_graph_match")

  (fn indexed-graph-for-each ((in g IndexedGraph)
                              (in subj (Option Term))
                              (in pred (Option Term))
                              (in obj (Option Term))
                              (callback (Fn (Triple) Unit)))
    (@intent "Call callback for each matching triple - zero allocation")
    (@spec ((IndexedGraph (Option Term) (Option Term) (Option Term) (Fn (Triple) Unit)) -> Unit))
    (@pure)
    (@pre (>= (. g size) 0))
    ;; Iterate all triples and filter by pattern, calling callback for matches
    (for-each (t (. g triples))
      (let ((matches true))
        (match subj
          ((some s) (when (not (term-eq (triple-subject t) s)) (set! matches false)))
          ((none) (do)))
        (match pred
          ((some p) (when (not (term-eq (triple-predicate t) p)) (set! matches false)))
          ((none) (do)))
        (match obj
          ((some o) (when (not (term-eq (triple-object t) o)) (set! matches false)))
          ((none) (do)))
        (when matches
          (callback t))))
    :c-name "rdf_indexed_graph_for_each")

  (fn indexed-graph-size ((in g IndexedGraph))
    (@intent "Return the number of triples in the graph")
    (@spec ((IndexedGraph) -> (Int 0 ..)))
    (@pure)
    (@post (== $result (. g size)))
    (. g size)
    :c-name "rdf_indexed_graph_size")

  (fn indexed-graph-subjects ((in arena Arena) (in g IndexedGraph) (in pred Term) (in obj Term))
    (@intent "Find all subjects with given predicate and object")
    (@spec ((Arena IndexedGraph Term Term) -> (List Term)))
    (@alloc arena)
    (@pre (>= (. g size) 0))
    (let ((mut result (list-new arena Term))
          (osp-idx (. (. g index) osp)))
      (match (map-get osp-idx obj)
        ((some subj-map)
          (for-each (s (map-keys subj-map))
            (match (map-get subj-map s)
              ((some pred-set)
                (when (set-has pred-set pred)
                  (list-push result s)))
              ((none) (do)))))
        ((none) (do)))
      result)
    :c-name "rdf_indexed_graph_subjects")

  (fn indexed-graph-objects ((in arena Arena) (in g IndexedGraph) (in subj Term) (in pred Term))
    (@intent "Find all objects with given subject and predicate")
    (@spec ((Arena IndexedGraph Term Term) -> (List Term)))
    (@alloc arena)
    (@pre (>= (. g size) 0))
    (let ((mut result (list-new arena Term))
          (spo-idx (. (. g index) spo)))
      (match (map-get spo-idx subj)
        ((some pred-map)
          (match (map-get pred-map pred)
            ((some obj-set)
              (for-each (o (set-elements obj-set))
                (list-push result o)))
            ((none) (do))))
        ((none) (do)))
      result)
    :c-name "rdf_indexed_graph_objects"))
